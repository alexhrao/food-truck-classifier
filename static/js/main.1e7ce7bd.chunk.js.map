{"version":3,"sources":["SingleLabelGroup.tsx","MultipleLabelGroup.tsx","NumericLabelGroup.tsx","api.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["SingleLabelGroup","groupName","value","labels","onChange","radios","map","label","type","key","name","checked","className","MultipleLabelGroup","checks","includes","fedValue","filter","v","NumericLabelGroup","rangeDescription","range","title","min","max","undefined","e","target","parseInt","getLabels","a","fetch","then","resp","json","getNextImage","commitLabels","doc","valid","bucket","body","JSON","stringify","method","App","props","state","imgDoc","setState","imageDocument","labelGroups","this","group","ind","findIndex","g","groupType","val","newInd","push","_","i","filename","src","alt","onClick","window","confirm","React","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.1e7ce7bd.chunk.js","sourcesContent":["import React from 'react';\nimport './LabelGroup.css';\n\ninterface SingleLabelGroupProps {\n    groupName: string;\n    labels: string[];\n    value?: string;\n    onChange: (newVal: string) => unknown;\n};\n\nconst SingleLabelGroup: React.FC<SingleLabelGroupProps> = ({ groupName, value, labels, onChange }) => {\n    const radios = labels.map(label => {\n        return (\n            <label>\n                <input\n                    type=\"radio\"\n                    key={label}\n                    name={groupName}\n                    checked={value === label} \n                    onChange={() => {\n                        onChange(label);\n                    }}\n                />\n                {label}\n            </label>\n        )\n    });\n    return (\n        <div className=\"label-group\">\n            <p className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                {radios}\n            </div>\n        </div>\n    );\n};\n\nexport default SingleLabelGroup;","import React from 'react';\nimport './LabelGroup.css';\n\ninterface MultipleLabelGroupProps {\n    groupName: string;\n    labels: string[];\n    value: string[];\n    onChange: (newVal: string[]) => unknown;\n};\n\nconst MultipleLabelGroup: React.FC<MultipleLabelGroupProps> = ({ groupName, labels, value, onChange }) => {\n    const checks = labels.map(label => {\n        return (\n            <label>\n                <input\n                    type=\"checkbox\"\n                    key={label}\n                    checked={value.includes(label)} \n                    onChange={() => {\n                        let fedValue: string[];\n                        if (value.includes(label)) {\n                            fedValue = value.filter(v => v !== label);\n                        } else {\n                            fedValue = [...value, label];\n                        }\n                        onChange(fedValue);\n                    }}\n                    />\n                {label}\n            </label>\n        )\n    });\n    return (\n        <div className=\"label-group\">\n            <p className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                {checks}\n            </div>\n        </div>\n    );\n};\n\nexport default MultipleLabelGroup;","import React from 'react';\nimport './LabelGroup.css';\n\ninterface NumericLabelGroupProps {\n    groupName: string;\n    range: number[];\n    value?: number;\n    onChange: (newVal?: number) => unknown;\n};\n\nconst NumericLabelGroup: React.FC<NumericLabelGroupProps> = ({ groupName, range, value, onChange }) => {\n    let rangeDescription: string;\n    if (range[1] < range[0]) {\n        rangeDescription = `Enter a number at or above ${range[0]}`;\n    } else {\n        rangeDescription = `Enter a number between ${range[0]} and ${range[1]}, inclusive`;\n    }\n    return (\n        <div className=\"label-group\">\n            <p title={rangeDescription} className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                <input\n                    title={rangeDescription}\n                    type=\"number\"\n                    value={value}\n                    min={range[0]}\n                    max={range[1] < range[0] ? undefined : range[1]}\n                    onChange={e => onChange(e.target.value === '' ? undefined : parseInt(e.target.value))}\n                />\n            </div>\n        </div>\n    );\n};\n\nexport default NumericLabelGroup;","\ninterface CategoryLabelGroup {\n    groupName: string;\n    groupType: 'single'|'multiple';\n    labels: string[];\n}\n\ninterface NumericLabelGroup {\n    groupName: string;\n    groupType: 'numeric';\n    range: number[];\n}\n\nexport type LabelGroup = CategoryLabelGroup | NumericLabelGroup;\n\n\ninterface SingleImageLabel {\n    groupName: string;\n    groupType: 'single';\n    value: string;\n}\n\ninterface MultipleImageLabel {\n    groupName: string;\n    groupType: 'multiple';\n    value: string[];\n}\n\ninterface NumericImageLabel {\n    groupName: string;\n    groupType: 'numeric';\n    value: number;\n}\n\nexport type ImageLabelGroup = SingleImageLabel | MultipleImageLabel | NumericImageLabel;\n\nexport interface ImageDocument {\n    key: string;\n    bucket: string;\n    filename: string;\n    valid: boolean;\n    seen: boolean;\n    labels: ImageLabelGroup[];\n}\n\nexport const getLabels = async (): Promise<LabelGroup[]> => {\n    return fetch('https://food-truck-spy.appspot.com/api/labels')\n        .then(resp => resp.json() as Promise<LabelGroup[]>);\n}\n\nexport const getNextImage = async (): Promise<ImageDocument> => {\n    return fetch('https://food-truck-spy.appspot.com/api/images/')\n        .then(resp => resp.json() as Promise<ImageDocument>);\n}\n\nexport const commitLabels = async (doc: ImageDocument): Promise<unknown> => {\n    if (!doc.valid) {\n        return fetch(`https://food-truck-spy.appspot.com/api/images/${doc.bucket}/${doc.key}`, {\n            body: JSON.stringify([]),\n            method: 'PUT'\n        });\n    }\n    return fetch(`https://food-truck-spy.appspot.com/api/images/${doc.bucket}/${doc.key}`, {\n        body: JSON.stringify(doc.labels),\n        method: 'PUT'\n    });\n}","import React from 'react';\nimport './App.css';\nimport SingleLabelGroup from './SingleLabelGroup';\nimport MultipleLabelGroup from './MultipleLabelGroup';\nimport NumericLabelGroup from './NumericLabelGroup';\nimport { LabelGroup, ImageDocument,  getLabels, getNextImage, commitLabels } from './api';\n\ninterface AppProps {};\n\ninterface AppState {\n  labelGroups?: LabelGroup[];\n  imageDocument?: ImageDocument;\n};\n\nexport default class App extends React.Component<AppProps, AppState> {\n  public constructor(props: AppProps) {\n    super(props);\n\n    this.state = {};\n    getNextImage()\n      .then(imgDoc => {\n        imgDoc.valid = true;\n        this.setState({ imageDocument: imgDoc })\n      });\n    getLabels()\n      .then(labels => this.setState({ labelGroups: labels }));\n  }\n\n  public render() {\n    const { labelGroups, imageDocument } = this.state;\n    if (labelGroups === undefined || imageDocument === undefined) {\n      return (\n        <div className=\"App\">\n          <p>Loading...</p>\n        </div>\n      )\n    }\n    const labels = labelGroups.map(group => {\n      const ind = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n      if (group.groupType === 'multiple') {\n        const val = ind !== -1 ? imageDocument.labels[ind].value as string[] : [];\n        return (\n          <MultipleLabelGroup key={group.groupName}\n            groupName={group.groupName}\n            labels={group.labels}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupType: 'multiple',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={val}\n          />\n        );\n      } else if (group.groupType === 'single') {\n        return (\n          <SingleLabelGroup key={group.groupName}\n            groupName={group.groupName}\n            labels={group.labels}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupType: 'single',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={ind !== -1 ? imageDocument.labels[ind].value as string : undefined}\n          />\n        );\n      } else if (group.groupType === 'numeric') {\n        return (\n          <NumericLabelGroup key={group.groupName}\n            groupName={group.groupName}\n            range={group.range}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (v === undefined) {\n                if (newInd !== -1) {\n                  imageDocument.labels = imageDocument.labels.filter((_, i) => i !== ind);\n                }\n              } else if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupType: 'numeric',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={ind !== -1 ? imageDocument.labels[ind].value as number : undefined}\n          />\n        );\n      } else {\n        return null;\n      }\n    });\n    return (\n      <div className=\"App\">\n        <h1>{imageDocument.filename}</h1>\n        <img src={`https://food-truck-spy.appspot.com/api/snapshots/${imageDocument.bucket}/${imageDocument.key}`} alt=\"Classify\" />\n        <div className=\"label-groups\">\n          {labels}\n        </div>\n        <button\n          type=\"button\"\n          className=\"submit\"\n          onClick={() => {\n            this.setState({ imageDocument: undefined });\n            commitLabels(imageDocument)\n              .then(() => {\n                getNextImage()\n                  .then(imgDoc => this.setState({ imageDocument: imgDoc }));\n              })\n          }}\n        >\n          Commit Changes\n        </button>\n        <button\n          type=\"button\"\n          className=\"invalidate\"\n          onClick={() => {\n            if (!window.confirm('Are you sure you wish to invalidate this photo? It will be deleted from the datastore. This cannot be undone!')) {\n              return;\n            }\n            this.setState({ imageDocument: undefined });\n            imageDocument.valid = false;\n            commitLabels(imageDocument)\n              .then(() => {\n                getNextImage()\n                  .then(imgDoc => this.setState({ imageDocument: imgDoc }));\n              })\n          }}\n        >\n          This is invalid!\n        </button>\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}