{"version":3,"sources":["SingleLabelGroup.tsx","MultipleLabelGroup.tsx","NumericLabelGroup.tsx","api.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["SingleLabelGroup","groupName","value","labels","onChange","radios","map","label","i","key","type","tabIndex","name","checked","left","right","length","push","className","MultipleLabelGroup","checks","includes","fedValue","filter","v","NumericLabelGroup","rangeDescription","range","title","min","max","undefined","e","target","parseInt","getLabels","a","fetch","then","resp","json","group","groupType","sort","l","getNextImage","commitLabels","doc","bucket","body","JSON","stringify","method","App","props","commitChanges","setState","imageDocument","imgDoc","state","labelGroups","window","onkeypress","this","ind","findIndex","g","val","newInd","groupId","_","filename","src","alt","onClick","React","Component","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"kUAiDeA,G,WAvC2C,SAAC,GAoBvD,IApBmG,IAA1CC,EAAyC,EAAzCA,UAAWC,EAA8B,EAA9BA,MAAOC,EAAuB,EAAvBA,OAAQC,EAAe,EAAfA,SAC7EC,EAASF,EAAOG,KAAI,SAACC,EAAOC,GAC9B,OACI,2BAAOC,IAAKF,GACR,2BACIG,KAAK,QACLD,IAAKF,EACLI,SAAUH,EACVI,KAAMX,EACNY,QAASX,IAAUK,EACnBH,SAAU,WACNA,EAASG,MAGhBA,MAIPO,EAAsB,GACtBC,EAAuB,GACpBP,EAAI,EAAGA,EAAIH,EAAOW,OAAQR,GAAK,EACpCM,EAAKG,KAAKZ,EAAOG,IACjBO,EAAME,KAAKZ,EAAOG,EAAE,IAExB,OACI,yBAAKU,UAAU,eACX,uBAAGA,UAAU,eAAejB,GAC5B,yBAAKiB,UAAU,gBACX,yBAAKA,UAAU,eACVJ,GAEL,yBAAKI,UAAU,gBACVH,O,OCANI,EAhC+C,SAAC,GAA4C,IAA1ClB,EAAyC,EAAzCA,UAAWE,EAA8B,EAA9BA,OAAQD,EAAsB,EAAtBA,MAAOE,EAAe,EAAfA,SACjFgB,EAASjB,EAAOG,KAAI,SAAAC,GACtB,OACI,+BACI,2BACIG,KAAK,WACLD,IAAKF,EACLM,QAASX,EAAMmB,SAASd,GACxBH,SAAU,WACN,IAAIkB,EAEAA,EADApB,EAAMmB,SAASd,GACJL,EAAMqB,QAAO,SAAAC,GAAC,OAAIA,IAAMjB,KAE3B,sBAAOL,GAAP,CAAcK,IAE1BH,EAASkB,MAGhBf,MAIb,OACI,yBAAKW,UAAU,eACX,uBAAGA,UAAU,eAAejB,GAC5B,yBAAKiB,UAAU,gBACVE,KCFFK,EAxB6C,SAAC,GAA2C,IAChGC,EADuDzB,EAAwC,EAAxCA,UAAW0B,EAA6B,EAA7BA,MAAOzB,EAAsB,EAAtBA,MAAOE,EAAe,EAAfA,SAOpF,OAJIsB,EADAC,EAAM,GAAKA,EAAM,GACD,qCAAiCA,EAAM,IAEvC,iCAA6BA,EAAM,GAAnC,gBAA6CA,EAAM,GAAnD,eAGhB,yBAAKT,UAAU,eACX,uBAAGU,MAAOF,EAAkBR,UAAU,eAAejB,GACrD,yBAAKiB,UAAU,gBACX,2BACIU,MAAOF,EACPhB,KAAK,SACLR,MAAOA,EACP2B,IAAKF,EAAM,GACXG,IAAKH,EAAM,GAAKA,EAAM,QAAKI,EAAYJ,EAAM,GAC7CvB,SAAU,SAAA4B,GAAC,OAAI5B,EAA4B,KAAnB4B,EAAEC,OAAO/B,WAAe6B,EAAYG,SAASF,EAAEC,OAAO/B,cCuBrFiC,EAAS,uCAAG,sBAAAC,EAAA,+EACdC,MAAM,iDACRC,MAAK,SAAAC,GAAI,OAAIA,EAAKC,UAClBF,MAAK,SAAAnC,GACF,OAAOA,EAAOG,KAAI,SAAAmC,GAOd,MANwB,aAApBA,EAAMC,WAAgD,WAApBD,EAAMC,YACxCD,EAAMtC,OAAOwC,OACTF,EAAMtC,OAAOkB,SAAS,UACtBoB,EAAMtC,OAAN,CAAgB,QAAhB,mBAA2BsC,EAAMtC,OAAOoB,QAAO,SAAAqB,GAAC,MAAU,SAANA,SAGrDH,SAXE,2CAAH,qDAgBTI,EAAY,uCAAG,sBAAAT,EAAA,+EACjBC,MAAM,kDACRC,MAAK,SAAAC,GAAI,OAAIA,EAAKC,WAFC,2CAAH,qDAKZM,EAAY,uCAAG,WAAOC,GAAP,SAAAX,EAAA,+EACjBC,MAAM,iDAAD,OAAkDU,EAAIC,OAAtD,YAAgED,EAAItC,KAAO,CACnFwC,KAAMC,KAAKC,UAAUJ,EAAI5C,QACzBiD,OAAQ,SAHY,2CAAH,sDCzDJC,E,YACnB,WAAmBC,GAAkB,IAAD,8BAClC,4CAAMA,KAkBAC,cAnB4B,uCAmBZ,WAAOR,GAAP,SAAAX,EAAA,6DACtB,EAAKoB,SAAS,CAAEC,mBAAe1B,IADT,kBAEfe,EAAaC,GACjBT,MAAK,WACJO,IACGP,MAAK,SAAAoB,GAAM,OAAI,EAAKF,SAAS,CAAEC,cAAeC,WAL/B,2CAnBY,sDAGlC,EAAKC,MAAQ,GACbd,IACGP,MAAK,SAAAoB,GAAM,OAAI,EAAKF,SAAS,CAAEC,cAAeC,OACjDvB,IACGG,MAAK,SAAAnC,GAAM,OAAI,EAAKqD,SAAS,CAAEI,YAAazD,OAC/C0D,OAAOC,WAAa,SAAC9B,GACnB,GAAc,UAAVA,EAAEvB,IAAiB,CAAC,IACdgD,EAAkB,EAAKE,MAAvBF,cACR,QAAsB1B,IAAlB0B,EACF,OAEF,EAAKF,cAAcE,KAdW,E,sEA4BnB,IAAD,SACyBM,KAAKJ,MAApCC,EADM,EACNA,YAAaH,EADP,EACOA,cACrB,QAAoB1B,IAAhB6B,QAA+C7B,IAAlB0B,EAC/B,OACE,yBAAKvC,UAAU,OACb,0CAIN,IAAMf,EAASyD,EAAYtD,KAAI,SAAAmC,GAC7B,IAAMuB,EAAMP,EAActD,OAAO8D,WAAU,SAAAC,GAAC,OAAIA,EAAEjE,YAAcwC,EAAMxC,aACtE,GAAwB,aAApBwC,EAAMC,UAA0B,CAClC,IAAMyB,GAAe,IAATH,EAAaP,EAActD,OAAO6D,GAAK9D,MAAoB,GACvE,OACE,kBAAC,EAAD,CAAoBO,IAAKgC,EAAMxC,UAC7BA,UAAWwC,EAAMxC,UACjBE,OAAQsC,EAAMtC,OACdC,SAAU,SAAAoB,GAER,IAAM4C,EAASX,EAActD,OAAO8D,WAAU,SAAAC,GAAC,OAAIA,EAAEjE,YAAcwC,EAAMxC,cACzD,IAAZmE,EAEFX,EAActD,OAAOc,KAAK,CACxBhB,UAAWwC,EAAMxC,UACjBoE,QAAS5B,EAAM4B,QACf3B,UAAW,WACXxC,MAAOsB,IAITiC,EAActD,OAAOiE,GAAQlE,MAAQsB,EAEvC,EAAKgC,SAAS,CAAEC,mBAElBvD,MAAOiE,IAGN,MAAwB,WAApB1B,EAAMC,UAEb,kBAAC,EAAD,CAAkBjC,IAAKgC,EAAMxC,UAC3BA,UAAWwC,EAAMxC,UACjBE,OAAQsC,EAAMtC,OACdC,SAAU,SAAAoB,GAER,IAAM4C,EAASX,EAActD,OAAO8D,WAAU,SAAAC,GAAC,OAAIA,EAAEjE,YAAcwC,EAAMxC,cACzD,IAAZmE,EAEFX,EAActD,OAAOc,KAAK,CACxBhB,UAAWwC,EAAMxC,UACjBoE,QAAS5B,EAAM4B,QACf3B,UAAW,SACXxC,MAAOsB,IAITiC,EAActD,OAAOiE,GAAQlE,MAAQsB,EAEvC,EAAKgC,SAAS,CAAEC,mBAElBvD,OAAgB,IAAT8D,EAAaP,EAActD,OAAO6D,GAAK9D,WAAkB6B,IAGvC,YAApBU,EAAMC,UAEb,kBAAC,EAAD,CAAmBjC,IAAKgC,EAAMxC,UAC5BA,UAAWwC,EAAMxC,UACjB0B,MAAOc,EAAMd,MACbvB,SAAU,SAAAoB,GAER,IAAM4C,EAASX,EAActD,OAAO8D,WAAU,SAAAC,GAAC,OAAIA,EAAEjE,YAAcwC,EAAMxC,kBAC/D8B,IAANP,GACc,IAAZ4C,IACFX,EAActD,OAASsD,EAActD,OAAOoB,QAAO,SAAC+C,EAAG9D,GAAJ,OAAUA,IAAMwD,OAEhD,IAAZI,EAETX,EAActD,OAAOc,KAAK,CACxBhB,UAAWwC,EAAMxC,UACjBoE,QAAS5B,EAAM4B,QACf3B,UAAW,UACXxC,MAAOsB,IAITiC,EAActD,OAAOiE,GAAQlE,MAAQsB,EAEvC,EAAKgC,SAAS,CAAEC,mBAElBvD,OAAgB,IAAT8D,EAAaP,EAActD,OAAO6D,GAAK9D,WAAkB6B,IAI7D,QAGX,OACE,yBAAKb,UAAU,OACb,4BAAKuC,EAAcc,UACnB,yBAAKrD,UAAU,mBACb,yBAAKsD,IAAG,2DAAsDf,EAAcT,OAApE,YAA8ES,EAAchD,KAAOgE,IAAI,cAEjH,yBAAKvD,UAAU,mBACb,yBAAKA,UAAU,gBACZf,GAEH,yBAAKe,UAAU,gBACb,4BACER,KAAK,SACLgE,QAAS,kBAAM,EAAKnB,cAAcE,KAFpC,kBAMA,4BACE/C,KAAK,SACLgE,QAAS,WACPjB,EAActD,OAAS,GACvB,EAAKoD,cAAcE,KAJvB,0B,GA7IqBkB,IAAMC,WCFnBC,QACW,cAA7BhB,OAAOiB,SAASC,UAEe,UAA7BlB,OAAOiB,SAASC,UAEhBlB,OAAOiB,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SDqI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMjD,MAAK,SAAAkD,GACjCA,EAAaC,iB","file":"static/js/main.273def62.chunk.js","sourcesContent":["import React from 'react';\nimport './LabelGroup.css';\n\ninterface SingleLabelGroupProps {\n    groupName: string;\n    labels: string[];\n    value?: string;\n    onChange: (newVal: string) => unknown;\n};\n\nconst SingleLabelGroup: React.FC<SingleLabelGroupProps> = ({ groupName, value, labels, onChange }) => {\n    const radios = labels.map((label, i) => {\n        return (\n            <label key={label}>\n                <input\n                    type=\"radio\"\n                    key={label}\n                    tabIndex={i}\n                    name={groupName}\n                    checked={value === label} \n                    onChange={() => {\n                        onChange(label);\n                    }}\n                />\n                {label}\n            </label>\n        )\n    });\n    const left: JSX.Element[] = [];\n    const right: JSX.Element[] = [];\n    for (let i = 0; i < radios.length; i += 2) {\n        left.push(radios[i]);\n        right.push(radios[i+1]);\n    }\n    return (\n        <div className=\"label-group\">\n            <p className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                <div className=\"left-labels\">\n                    {left}\n                </div>\n                <div className=\"right-labels\">\n                    {right}\n                </div>\n            </div>\n        </div>\n    );\n};\n\nexport default SingleLabelGroup;","import React from 'react';\nimport './LabelGroup.css';\n\ninterface MultipleLabelGroupProps {\n    groupName: string;\n    labels: string[];\n    value: string[];\n    onChange: (newVal: string[]) => unknown;\n};\n\nconst MultipleLabelGroup: React.FC<MultipleLabelGroupProps> = ({ groupName, labels, value, onChange }) => {\n    const checks = labels.map(label => {\n        return (\n            <label>\n                <input\n                    type=\"checkbox\"\n                    key={label}\n                    checked={value.includes(label)} \n                    onChange={() => {\n                        let fedValue: string[];\n                        if (value.includes(label)) {\n                            fedValue = value.filter(v => v !== label);\n                        } else {\n                            fedValue = [...value, label];\n                        }\n                        onChange(fedValue);\n                    }}\n                    />\n                {label}\n            </label>\n        )\n    });\n    return (\n        <div className=\"label-group\">\n            <p className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                {checks}\n            </div>\n        </div>\n    );\n};\n\nexport default MultipleLabelGroup;","import React from 'react';\nimport './LabelGroup.css';\n\ninterface NumericLabelGroupProps {\n    groupName: string;\n    range: number[];\n    value?: number;\n    onChange: (newVal?: number) => unknown;\n};\n\nconst NumericLabelGroup: React.FC<NumericLabelGroupProps> = ({ groupName, range, value, onChange }) => {\n    let rangeDescription: string;\n    if (range[1] < range[0]) {\n        rangeDescription = `Enter a number at or above ${range[0]}`;\n    } else {\n        rangeDescription = `Enter a number between ${range[0]} and ${range[1]}, inclusive`;\n    }\n    return (\n        <div className=\"label-group\">\n            <p title={rangeDescription} className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                <input\n                    title={rangeDescription}\n                    type=\"number\"\n                    value={value}\n                    min={range[0]}\n                    max={range[1] < range[0] ? undefined : range[1]}\n                    onChange={e => onChange(e.target.value === '' ? undefined : parseInt(e.target.value))}\n                />\n            </div>\n        </div>\n    );\n};\n\nexport default NumericLabelGroup;","\ninterface CategoryLabelGroup {\n    groupName: string;\n    groupId: string;\n    groupType: 'single'|'multiple';\n    labels: string[];\n}\n\ninterface NumericLabelGroup {\n    groupName: string;\n    groupId: string;\n    groupType: 'numeric';\n    range: number[];\n}\n\nexport type LabelGroup = CategoryLabelGroup | NumericLabelGroup;\n\n\ninterface SingleImageLabel {\n    groupName: string;\n    groupId: string;\n    groupType: 'single';\n    value: string;\n}\n\ninterface MultipleImageLabel {\n    groupName: string;\n    groupId: string;\n    groupType: 'multiple';\n    value: string[];\n}\n\ninterface NumericImageLabel {\n    groupName: string;\n    groupId: string;\n    groupType: 'numeric';\n    value: number;\n}\n\nexport type ImageLabelGroup = SingleImageLabel | MultipleImageLabel | NumericImageLabel;\n\nexport interface ImageDocument {\n    key: string;\n    bucket: string;\n    filename: string;\n    valid: boolean;\n    seen: boolean;\n    labels: ImageLabelGroup[];\n}\n\nexport const getLabels = async (): Promise<LabelGroup[]> => {\n    return fetch('https://food-truck-spy.appspot.com/api/labels')\n        .then(resp => resp.json() as Promise<LabelGroup[]>)\n        .then(labels => {\n            return labels.map(group => {\n                if (group.groupType === 'multiple' || group.groupType === 'single') {\n                    group.labels.sort();\n                    if (group.labels.includes('none')) {\n                        group.labels = ['none', ...group.labels.filter(l => l !== 'none')];\n                    }\n                }\n                return group;\n            })\n        })\n}\n\nexport const getNextImage = async (): Promise<ImageDocument> => {\n    return fetch('https://food-truck-spy.appspot.com/api/images/')\n        .then(resp => resp.json() as Promise<ImageDocument>);\n}\n\nexport const commitLabels = async (doc: ImageDocument): Promise<unknown> => {\n    return fetch(`https://food-truck-spy.appspot.com/api/images/${doc.bucket}/${doc.key}`, {\n        body: JSON.stringify(doc.labels),\n        method: 'PUT'\n    });\n}","import React from 'react';\nimport './App.css';\nimport SingleLabelGroup from './SingleLabelGroup';\nimport MultipleLabelGroup from './MultipleLabelGroup';\nimport NumericLabelGroup from './NumericLabelGroup';\nimport { LabelGroup, ImageDocument,  getLabels, getNextImage, commitLabels } from './api';\n\ninterface AppProps {};\n\ninterface AppState {\n  labelGroups?: LabelGroup[];\n  imageDocument?: ImageDocument;\n};\n\nexport default class App extends React.Component<AppProps, AppState> {\n  public constructor(props: AppProps) {\n    super(props);\n\n    this.state = {};\n    getNextImage()\n      .then(imgDoc => this.setState({ imageDocument: imgDoc }));\n    getLabels()\n      .then(labels => this.setState({ labelGroups: labels }));\n    window.onkeypress = (e: KeyboardEvent) => {\n      if (e.key === 'Enter') {\n        const { imageDocument } = this.state;\n        if (imageDocument === undefined) {\n          return;\n        }\n        this.commitChanges(imageDocument);\n      }\n    }\n  }\n\n  private commitChanges = async (doc: ImageDocument): Promise<void> => {\n    this.setState({ imageDocument: undefined });\n    return commitLabels(doc)\n      .then(() => {\n        getNextImage()\n          .then(imgDoc => this.setState({ imageDocument: imgDoc }));\n      });\n  };\n\n  public render() {\n    const { labelGroups, imageDocument } = this.state;\n    if (labelGroups === undefined || imageDocument === undefined) {\n      return (\n        <div className=\"App\">\n          <p>Loading...</p>\n        </div>\n      )\n    }\n    const labels = labelGroups.map(group => {\n      const ind = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n      if (group.groupType === 'multiple') {\n        const val = ind !== -1 ? imageDocument.labels[ind].value as string[] : [];\n        return (\n          <MultipleLabelGroup key={group.groupName}\n            groupName={group.groupName}\n            labels={group.labels}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupId: group.groupId,\n                  groupType: 'multiple',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={val}\n          />\n        );\n      } else if (group.groupType === 'single') {\n        return (\n          <SingleLabelGroup key={group.groupName}\n            groupName={group.groupName}\n            labels={group.labels}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupId: group.groupId,\n                  groupType: 'single',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={ind !== -1 ? imageDocument.labels[ind].value as string : undefined}\n          />\n        );\n      } else if (group.groupType === 'numeric') {\n        return (\n          <NumericLabelGroup key={group.groupName}\n            groupName={group.groupName}\n            range={group.range}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (v === undefined) {\n                if (newInd !== -1) {\n                  imageDocument.labels = imageDocument.labels.filter((_, i) => i !== ind);\n                }\n              } else if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupId: group.groupId,\n                  groupType: 'numeric',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={ind !== -1 ? imageDocument.labels[ind].value as number : undefined}\n          />\n        );\n      } else {\n        return null;\n      }\n    });\n    return (\n      <div className=\"App\">\n        <h1>{imageDocument.filename}</h1>\n        <div className=\"image-container\">\n          <img src={`https://food-truck-spy.appspot.com/api/snapshots/${imageDocument.bucket}/${imageDocument.key}`} alt=\"Classify\" />\n        </div>\n        <div className=\"label-container\">\n          <div className=\"label-groups\">\n            {labels}\n          </div>\n          <div className=\"button-group\">\n            <button\n              type=\"button\"\n              onClick={() => this.commitChanges(imageDocument)}\n            >\n              Commit Changes\n            </button>\n            <button\n              type=\"button\"\n              onClick={() => {\n                imageDocument.labels = [];\n                this.commitChanges(imageDocument);\n              }}\n            >\n              Mark as Invalid\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}