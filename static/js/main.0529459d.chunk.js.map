{"version":3,"sources":["SingleLabelGroup.tsx","MultipleLabelGroup.tsx","NumericLabelGroup.tsx","api.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["SingleLabelGroup","groupName","value","labels","onChange","radios","map","label","type","name","checked","className","MultipleLabelGroup","checks","includes","fedValue","filter","v","NumericLabelGroup","rangeDescription","range","placeholder","e","target","undefined","parseInt","getLabels","a","fetch","then","resp","json","getNextImage","commitLabels","doc","bucket","key","body","JSON","stringify","method","App","props","state","imgDoc","setState","imageDocument","labelGroups","this","group","ind","findIndex","g","groupType","val","newInd","push","_","i","filename","src","alt","onClick","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.0529459d.chunk.js","sourcesContent":["import React from 'react';\nimport './LabelGroup.css';\n\ninterface SingleLabelGroupProps {\n    groupName: string;\n    labels: string[];\n    value?: string;\n    onChange: (newVal: string) => unknown;\n};\n\nconst SingleLabelGroup: React.FC<SingleLabelGroupProps> = ({ groupName, value, labels, onChange }) => {\n    const radios = labels.map(label => {\n        return (\n            <label>\n                <input\n                    type=\"radio\"\n                    name={groupName}\n                    checked={value === label} \n                    onChange={() => {\n                        onChange(label);\n                    }}\n                />\n                {label}\n            </label>\n        )\n    });\n    return (\n        <div className=\"label-group\">\n            <p className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                {radios}\n            </div>\n        </div>\n    );\n};\n\nexport default SingleLabelGroup;","import React from 'react';\nimport './LabelGroup.css';\n\ninterface MultipleLabelGroupProps {\n    groupName: string;\n    labels: string[];\n    value: string[];\n    onChange: (newVal: string[]) => unknown;\n};\n\nconst MultipleLabelGroup: React.FC<MultipleLabelGroupProps> = ({ groupName, labels, value, onChange }) => {\n    const checks = labels.map(label => {\n        return (\n            <label>\n                <input\n                    type=\"checkbox\"\n                    checked={value.includes(label)} \n                    onChange={() => {\n                        let fedValue: string[];\n                        if (value.includes(label)) {\n                            fedValue = value.filter(v => v !== label);\n                        } else {\n                            fedValue = [...value, label];\n                        }\n                        onChange(fedValue);\n                    }}\n                    />\n                {label}\n            </label>\n        )\n    });\n    return (\n        <div className=\"label-group\">\n            <p className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                {checks}\n            </div>\n        </div>\n    );\n};\n\nexport default MultipleLabelGroup;","import React from 'react';\nimport './LabelGroup.css';\n\ninterface NumericLabelGroupProps {\n    groupName: string;\n    range: number[];\n    value?: number;\n    onChange: (newVal?: number) => unknown;\n};\n\nconst NumericLabelGroup: React.FC<NumericLabelGroupProps> = ({ groupName, range, value, onChange }) => {\n    let rangeDescription: string;\n    if (range[1] < range[0]) {\n        rangeDescription = `Enter a number at or above ${range[0]}`;\n    } else {\n        rangeDescription = `Enter a number between ${range[0]} and ${range[1]}, inclusive`;\n    }\n    return (\n        <div className=\"label-group\">\n            <p className=\"group-title\">{groupName}</p>\n            <div className=\"group-labels\">\n                <input\n                    type=\"number\"\n                    value={value}\n                    placeholder={rangeDescription}\n                    onChange={e => onChange(e.target.value === '' ? undefined : parseInt(e.target.value))}\n                />\n            </div>\n        </div>\n    );\n};\n\nexport default NumericLabelGroup;","\ninterface CategoryLabelGroup {\n    groupName: string;\n    groupType: 'single'|'multiple';\n    labels: string[];\n}\n\ninterface NumericLabelGroup {\n    groupName: string;\n    groupType: 'numeric';\n    range: number[];\n}\n\nexport type LabelGroup = CategoryLabelGroup | NumericLabelGroup;\n\n\ninterface SingleImageLabel {\n    groupName: string;\n    groupType: 'single';\n    value: string;\n}\n\ninterface MultipleImageLabel {\n    groupName: string;\n    groupType: 'multiple';\n    value: string[];\n}\n\ninterface NumericImageLabel {\n    groupName: string;\n    groupType: 'numeric';\n    value: number;\n}\n\nexport type ImageLabelGroup = SingleImageLabel | MultipleImageLabel | NumericImageLabel;\n\nexport interface ImageDocument {\n    key: string;\n    bucket: string;\n    filename: string;\n    valid: boolean;\n    seen: boolean;\n    labels: ImageLabelGroup[];\n}\n\nexport const getLabels = async (): Promise<LabelGroup[]> => {\n    return fetch('https://food-truck-spy.appspot.com/api/labels')\n        .then(resp => resp.json() as Promise<LabelGroup[]>);\n}\n\nexport const getNextImage = async (): Promise<ImageDocument> => {\n    return fetch('https://food-truck-spy.appspot.com/api/images/')\n        .then(resp => resp.json() as Promise<ImageDocument>);\n}\n\nexport const commitLabels = async (doc: ImageDocument): Promise<unknown> => {\n    return fetch(`https://food-truck-spy.appspot.com/api/images/${doc.bucket}/${doc.key}`, {\n        body: JSON.stringify(doc.labels),\n        method: 'PUT'\n    });\n}","import React from 'react';\nimport './App.css';\nimport SingleLabelGroup from './SingleLabelGroup';\nimport MultipleLabelGroup from './MultipleLabelGroup';\nimport NumericLabelGroup from './NumericLabelGroup';\nimport { LabelGroup, ImageDocument,  getLabels, getNextImage, commitLabels } from './api';\n\ninterface AppProps {};\n\ninterface AppState {\n  labelGroups?: LabelGroup[];\n  imageDocument?: ImageDocument;\n};\n\nexport default class App extends React.Component<AppProps, AppState> {\n  public constructor(props: AppProps) {\n    super(props);\n\n    this.state = {};\n    getNextImage()\n      .then(imgDoc => this.setState({ imageDocument: imgDoc }));\n    getLabels()\n      .then(labels => this.setState({ labelGroups: labels }));\n  }\n\n  public render() {\n    const { labelGroups, imageDocument } = this.state;\n    if (labelGroups === undefined || imageDocument === undefined) {\n      return (\n        <div className=\"App\">\n          <p>Loading...</p>\n        </div>\n      )\n    }\n    const labels = labelGroups.map(group => {\n      const ind = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n      if (group.groupType === 'multiple') {\n        const val = ind !== -1 ? imageDocument.labels[ind].value as string[] : [];\n        return (\n          <MultipleLabelGroup\n            groupName={group.groupName}\n            labels={group.labels}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupType: 'multiple',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={val}\n          />\n        );\n      } else if (group.groupType === 'single') {\n        return (\n          <SingleLabelGroup\n            groupName={group.groupName}\n            labels={group.labels}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupType: 'single',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={ind !== -1 ? imageDocument.labels[ind].value as string : undefined}\n          />\n        );\n      } else if (group.groupType === 'numeric') {\n        return (\n          <NumericLabelGroup\n            groupName={group.groupName}\n            range={group.range}\n            onChange={v => {\n              // if we have one, update; otherwise, create!\n              const newInd = imageDocument.labels.findIndex(g => g.groupName === group.groupName);\n              if (v === undefined) {\n                if (newInd !== -1) {\n                  imageDocument.labels = imageDocument.labels.filter((_, i) => i !== ind);\n                }\n              } else if (newInd === -1) {\n                // add\n                imageDocument.labels.push({\n                  groupName: group.groupName,\n                  groupType: 'numeric',\n                  value: v,\n                });\n              } else {\n                // update\n                imageDocument.labels[newInd].value = v;\n              }\n              this.setState({ imageDocument });\n            }}\n            value={ind !== -1 ? imageDocument.labels[ind].value as number : undefined}\n          />\n        );\n      } else {\n        return null;\n      }\n    });\n    return (\n      <div className=\"App\">\n        <h1>{imageDocument.filename}</h1>\n        <img src={`https://food-truck-spy.appspot.com/api/snapshots/${imageDocument.bucket}/${imageDocument.key}`} alt=\"Classify\" />\n        <div className=\"label-groups\">\n          {labels}\n        </div>\n        <button\n          type=\"button\"\n          onClick={() => {\n            commitLabels(imageDocument)\n              .then(() => {\n                getNextImage()\n                  .then(imgDoc => this.setState({ imageDocument: imgDoc }));\n              })\n          }}\n        >\n          Commit Changes\n        </button>\n      </div>\n    );\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}